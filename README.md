Type Inference for Source 1
================================

Up and Running
--------------------

1. Make you sure you have the `js-slang` interpreter installed. 
   * To support CLI mode, you can apply the changes to the interpreter stated [here](https://gist.github.com/tysng/bc78a7cf263f1c736fa60a02c7b4906f).
2. Create a `.env` file and add the path to the `cli.js` (or `repl.js`) above, like

   ```
   JS_SLANG=/Users/ty/working/js-slang/dist/repl/cli.js
   ```
3. Use `make pack run` to consolidate all the `.js` files in the project folder to `\build\type_inferred_source.js`, and run the packed code file.



Specifications
-----------------

### Types
Type inference for Source 1 supports:
* `number`: `float` and `int`
* `bool`: for boolean types
* `string`
* `undefined`



### Annotation
```js
annotate(statement) -> annotated_statement
```
The `annotate` function takes an untyped parse tree of the Source program, and add 
a type variable to every node of the tree. The resulting tree should be backwards 
compatible with an interpreter that doesn't make use of the type information.

### Top-Level Transformation
```js
transform(annotated_statement) -> transformed_statement
```

To facilitates the constraint generation, we will wrap the top level statements 
in a block, and add `return` to the last statement in a sequence. 

### Constraint Generation
```js
generate_constraint({constraint}, transformed_statement, type_environment) -> {constraint}
```
A `constraint` is a pair of type variable and a type, and it represents the type 
constraints arose from the statements and their typing relations.

### Unification
Using the set of `constraint`s generated by the previous step, we solve the 
system of equations through substitution. 


### Generate typed syntax tree
Using the solution set, we can substitute the type variables in the annotated 
syntax tree to obtain the typed syntax tree.



