Type Inference for Source 1
================================


Specifications
-----------------

### Types and Typed Terms
A `typed_term` is a tagged list. Its second element is a type variable, in number; 
and the third element is a `type`.


A `type` is a tagged list, and its second element is a string of the following:
1. Primitive types: `number`, `bool`, `undefined`
2. `if` type: represents a conditional statement
   * its predicate, consequent and alternative are represented as typed terms
3. `function` type: represents a function definition
   * its parameter is a list of typed terms
   * the returned type is a type term
4. `let` type: for constant declaration
   * its third element is the name binding, represented by a string
   * its value is a typed term
5. `var` type: for a bounded name
   * its third element is the name
6. `app` type: for function application
   * the function is a typed term
   * the parameter is a list of typed terms



### Annotation
```
annotate(statement, environment) -> typed_term | sequence
```
The `annotate` function takes an untyped parse tree of the Source program, and add 
a type variable to every node of the tree.

### Constraint Generation
```
constraint(stmt) -> set of constraints
```
A `constraint` is a pair of type variable and a type, and it represents the type 
constraints given the typed term.

For example, an `if`-typed `typed_term` has the following structure:

```js
true ? 1 : 2; 
list("typed_term",
    1, // type variable
    list("type", "if",
        list("typed_term", 2, list("type", "bool", true)),
        list("typed_term", 3, list("type", "number", 1)),
        list("typed_term", 4, list("type", "number", 2))
        )
);
```
It will generate the following constraints:
```
t2 = bool
t3 = number
t4 = number
t3 = t1
t4 = t1
```


### Unification
Using the set of `constraint`s generated by the previous step, we solve the 
system of equations through substitution. We can solve the above example and get 
```
t1 = t3 = t4 = number
t2 = bool
```

### Generate typed syntax tree
Using the solution set, we can substitute the type variables in the annotated 
syntax tree to obtain the typed syntax tree.